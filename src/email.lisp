;;; RFC5322-compliant email parsing.
;;;
;;; For clarity, the name of each parser in this package is lifted directly from
;;; the spec and the layout of the parsers generally follows the ABNF, except
;;; where doing so literally would be inefficient. Specifically, some of the
;;; low-level character checks have been fused into smarter `take-while' calls.
;;;
;;; See also the following relevant sections in various RFCs.
;;;
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4
;;; - https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
;;; - https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1
;;;
;;; A note on obsolete syntax. From RFC 5322:
;;;
;;; > Section 4 of this document specifies an "obsolete" syntax. There are
;;; > references in section 3 to these obsolete syntactic elements. The rules of
;;; > the obsolete syntax are elements that have appeared in earlier versions of
;;; > this specification or have previously been widely used in Internet
;;; > messages. As such, these elements MUST be interpreted by parsers of
;;; > messages in order to be conformant to this specification. However, since
;;; > items in this syntax have been determined to be non-interoperable or to
;;; > cause significant problems for recipients of messages, they MUST NOT be
;;; > generated by creators of conformant messages.
;;;
;;; parcom/email supports parsing this obsolete syntax.

(defpackage parcom/email
  (:use :cl)
  (:import-from :parcom #:<*> #:<* #:*> #:<$)
  (:local-nicknames (#:p #:parcom))
  ;; --- Types --- ;;
  (:export #:address #:address-name #:address-domain))

(in-package :parcom/email)

;; --- Static Parsers --- ;;

(defparameter +@+ (p:char #\@))
(defparameter +bracket-open+ (p:char #\[))
(defparameter +bracket-close+ (p:char #\]))
(defparameter +period+ (p:char #\.))
(defparameter +skipws1+ (*> (p:any-if #'ws?) (p:consume #'ws?)))
(defparameter +paren-open+ (p:char #\())
(defparameter +paren-close+ (p:char #\)))
(defparameter +quote+ (p:char #\"))

;; --- Types --- ;;

(defstruct address
  "A valid email address. Must be obtained through the parsing process and cannot
be directly constructed by the user."
  (name   nil :type string)
  (domain nil :type string))

(defun pretty (addr &optional (stream nil))
  "Pretty-print an `address'."
  (format stream "~a@~a" (address-name addr) (address-domain addr)))

#+nil
(pretty (p:parse #'msg-id "colin@fosskers.ca"))

;; --- Entry --- ;;

;; TODO: Convert to a simple-array if not already one.
(declaim (ftype (function (string) boolean) valid-address?))
(defun valid-email-address? (s))

;; --- Parsers --- ;;

(defun addr-spec (offset)
  (funcall (<*> local-part (*> +@+ domain)) offset))

(defun local-part (offset)
  (funcall (p:alt #'dot-atom #'quoted-string #'obs-local-part) offset))

(defun domain (offset)
  (funcall (p:alt #'dot-atom #'domain-literal #'obs-domain) offset))

;; Whitespace: https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.2

(defun dot-atom (offset)
  (funcall (*> (p:opt #'cfws) (<* #'dot-atom-text (p:opt #'cfws))) offset))

#+nil
(p:parse #'dot-atom "   (hi)hello(there)    ")

(defun quoted-string (offset)
  "No whitespace around or within the quotes is considered actual content."
  (p:fmap (lambda (list) (apply #'concatenate 'string list))
          (funcall (*> (p:opt #'cfws)
                       +quote+
                       ;; FIXME: 2025-09-10 This `many' is wasteful and forces a
                       ;; reallocation into a single string above. I'm not sure
                       ;; how to get around it though, given that `fws' has a
                       ;; specific structure that is not just a matter of
                       ;; `consuming' over whitespace.
                       (<* (p:many (*> (p:opt #'fws)
                                       (sliding-take1 (lambda (a b)
                                                        (cond ((qtext? a) (values :one a))
                                                              ((quoted-pair? a b) (values :two b)))))))
                           (p:opt #'fws)
                           +quote+
                           (p:opt #'cfws)))
                   offset)))

#+nil
(p:parse #'quoted-string "\"hello \\\" there\"")

(declaim (ftype (function (character) boolean) qtext?))
(defun qtext? (c)
  (or (char= #\! c)
      (char<= #\# c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

;; NOTE: From the spec.
;;
;; > Runs of FWS, comment, or CFWS that occur between lexical tokens in a
;; > structured header field are semantically interpreted as a single space
;; > character.))
;;
;; I interpret this to mean that comments and run of spaces can be entirely
;; ignored within an address.
(defun cfws (offset)
  (funcall (p:alt (*> (p:many1 (*> (p:opt #'fws) #'comment))
                      (p:opt #'fws))
                  #'fws)
           offset))

(defun fws (offset)
  "Parser: Folding white space."
  (funcall (p:alt (*> (p:opt (*> (p:consume #'ws?)
                                 (p:any-if #'crlf?)))
                      +skipws1+)
                  #'obs-fws)
           offset))

#+nil
(p:parse #'fws "   ")

(defun obs-fws (offset)
  (funcall (*> +skipws1+
               (p:many (*> (p:any-if #'crlf?)
                           +skipws1+)))
           offset))

#+nil
(p:parse #'obs-fws "   ")

(defun comment (offset)
  "Yields NIL if successful."
  (funcall (p:between +paren-open+
                      (*> (p:many (*> (p:opt #'fws)
                                      #'ccontent))
                          (p:opt #'fws))
                      +paren-close+)
           offset))

#+nil
(p:parse #'comment "(hello(there))")

(defun ccontent (offset)
  (funcall (p:alt (sliding-take1 (lambda (a b)
                                   (cond ((ctext? a) (values :one a))
                                         ((quoted-pair? a b) (values :two b)))))
                  #'comment)
           offset))

#+nil
(p:parse #'ccontent "hello)")

(declaim (ftype (function (character) boolean) ctext?))
(defun ctext? (c)
  (or (char<= #\! c #\')
      (char<= #\* c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

(defun msg-id (offset)
  (p:fmap (lambda (list) (make-address :name (car list) :domain (cadr list)))
          (funcall (<*> #'id-left (*> +@+ #'id-right)) offset)))

#+nil
(p:parse #'msg-id "colin@fosskers.ca")

(defun id-left (offset)
  (funcall (p:alt #'dot-atom-text #'local-part) offset))

(defun id-right (offset)
  (funcall (p:alt #'dot-atom-text #'no-fold-literal #'domain) offset))

(defun no-fold-literal (offset)
  (funcall (p:recognize (*> +bracket-open+ #'many-dtext +bracket-close+)) offset))

(defun many-dtext (offset)
  "Parser: Potentially escaped characters."
  (funcall (sliding-take (lambda (a b)
                           (cond ((or (char<= #\! a #\Z)
                                      (char<= #\^ a #\~)
                                      (obs-no-ws-ctl? a))
                                  (values :one a))
                                 ((quoted-pair? a b)
                                  (values :two b)))))
           offset))

#+nil
(p:parse #'many-dtext "Hello\\ there")

(declaim (ftype (function (character) boolean) obs-no-ws-ctl?))
(defun obs-no-ws-ctl? (c)
  (or (char<= #\Soh c #\backspace)
      (char<= #\Vt c #\Page)
      (char<= #\So c #\Us)
      (char= #\Rubout c)))

(declaim (ftype (function (character character) boolean) quoted-pair?))
(defun quoted-pair? (a b)
  (and (char= a #\\)
       (or (char<= #\! b #\~)
           (ws? b)
           (char= b #\nul)
           (obs-no-ws-ctl? b)
           (crlf? b))))

#+nil
(quoted-pair? #\\ #\newline)

(declaim (ftype (function (character) boolean) atext?))
(defun atext? (c)
  "Printable US-ASCII characters not including specials."
  (or (p:ascii-letter? c)
      (p:digit? c)
      (char= c #\!)
      (char<= #\# c #\')
      (char<= #\* c #\+)
      (char= c #\-)
      (char= c #\/)
      (char= c #\=)
      (char= c #\?)
      (char<= #\^ c #\`)
      (char<= #\{ c #\~)))

(defun dot-atom-text (offset)
  "Parser: Simple dot-separated ascii atoms."
  (funcall (p:recognize (p:sep1 +period+ (p:take-while1 #'atext?))) offset))

(declaim (ftype (function (character) boolean) ws?))
(defun ws? (c)
  (or (char= c #\space)
      (char= c #\tab)))

(declaim (ftype (function (character) boolean) ws?))
(defun crlf? (c)
  (or (char= c #\newline)
      (char= c #\return)))

#+nil
(p:parse #'dot-atom-text "foo.bar.baz")

;; dtext           =   %d33-90 /          ; Printable US-ASCII
;;                     %d94-126 /         ;  characters not including
;;                     obs-dtext          ;  "[", "]", or "\"

;; obs-dtext       =   obs-NO-WS-CTL / quoted-pair)

;; quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp

;; VCHAR          =  %x21-7E)
;;                        ; visible (printing) characters

;; WSP            =  SP / HTAB)
;;                        ; white space

;; SP             =  %x20)

;; HTAB           =  %x09))
;;                        ; horizontal tab

;; obs-qp          =   \ (%d0 / obs-NO-WS-CTL / LF / CR)

;; LF             =  %x0A
;;                        ; linefeed

;; CR             =  %x0D
;;                        ; carriage return

;; obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control
;;                     %d11 /             ;  characters that do not
;;                     %d12 /             ;  include the carriage
;;                     %d14-31 /          ;  return, line feed, and
;;                     %d127              ;  white space characters

;; --- Utilities --- ;;

;; TODO: Remove consume2

;; (declaim (ftype (function ((function (character character) keyword))) consume2))
(defun consume2 (p)
  "Like `consume' from the main library, but inspects two characters at a time in
a sliding window. This is intended for the detection of slash-escaped character
pairs.

Note that the given predicate-lambda must yield a keyword. `:one' will advance
the parser by one place. `:two' will advance it by two (i.e. the escaped char
case). Anything else is equivalent to NIL and will halt the consumption.

In the event that the parser advanced to the very last character via a `:one'
step, a `#\Nul' character will be passed as the second one to the
predicate-lambda."
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\0))
                                  (kw (funcall p a b)))
                             (case kw
                               (:one (incf i))
                               (:two (incf i 2))
                               (t (return (- i offset)))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (p:ok next next))))

#+nil
(p:parse (consume2 (lambda (a b)
                     (cond ((and (char= a #\a) (char= b #\b)) :two)
                           ((char= a #\a) :one))))
         "aabb")

;; (declaim (ftype (function ((function (character character) (values keyword character)))
;;                           (values string fixnum))
;;                 sliding-take))
(defun sliding-take (f)
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((s (make-array 16 :element-type 'character :adjustable t :fill-pointer 0))
           (keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\Nul)))
                             (multiple-value-bind (kw c) (funcall f a b)
                               (case kw
                                 (:one
                                  (incf i)
                                  (vector-push-extend c s))
                                 (:two
                                  (incf i 2)
                                  (vector-push-extend c s))
                                 (t (return (- i offset))))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (values s next))))

#+nil
(p:parse (sliding-take (lambda (a b)
                         (cond ((and (char= a #\\)
                                     (char= b #\n))
                                (values :two #\newline))
                               (t (values :one a)))))
         "Hello \\n there!")

(defun sliding-take1 (f)
  (lambda (offset)
    (multiple-value-bind (res next) (funcall (sliding-take f) offset)
      (cond ((p:failure? res) (p:fail offset))
            ((p:empty? res) (p:fail offset))
            (t (values res next))))))

#+nil
(p:parse (sliding-take1 (lambda (a b)
                          (cond ((and (char= a #\\)
                                      (char= b #\n))
                                 (values :two #\newline))
                                (t (values :one a)))))
         "")
