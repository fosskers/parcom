;;; RFC5322-compliant email parsing.
;;;
;;; For clarity, the name of each parser in this package is lifted directly from
;;; the spec and the layout of the parsers generally follows the ABNF, except
;;; where doing so literally would be inefficient. Specifically, some of the
;;; low-level character checks have been fused into smarter `take-while' calls.
;;;
;;; See also the following relevant sections in various RFCs.
;;;
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4
;;; - https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
;;; - https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1
;;;
;;; A note on obsolete syntax. From RFC 5322:
;;;
;;; > Section 4 of this document specifies an "obsolete" syntax. There are
;;; > references in section 3 to these obsolete syntactic elements. The rules of
;;; > the obsolete syntax are elements that have appeared in earlier versions of
;;; > this specification or have previously been widely used in Internet
;;; > messages. As such, these elements MUST be interpreted by parsers of
;;; > messages in order to be conformant to this specification. However, since
;;; > items in this syntax have been determined to be non-interoperable or to
;;; > cause significant problems for recipients of messages, they MUST NOT be
;;; > generated by creators of conformant messages.
;;;
;;; parcom/email supports parsing this obsolete syntax.

(defpackage parcom/email
  (:use :cl)
  (:shadow #:atom)
  (:import-from :parcom #:<*> #:<* #:*> #:<$)
  (:local-nicknames (#:p #:parcom))
  ;; --- Exposed Parsers --- ;;
  (:export #:addr-spec #:msg-id)
  ;; --- Types --- ;;
  (:export #:address #:address-name #:address-domain)
  ;; --- Other --- ;;
  (:export #:parse #:valid-email-address? #:pretty))

(in-package :parcom/email)

;; --- Helpers --- ;;

(declaim (ftype (function (character) boolean) ws?))
(defun ws? (c)
  (or (char= c #\space)
      (char= c #\tab)))

(declaim (ftype (function (character) boolean) crlf?))
(defun crlf? (c)
  (or (char= c #\newline)
      (char= c #\return)))

(declaim (ftype (function (character) boolean) atext?))
(defun atext? (c)
  "Printable US-ASCII characters not including specials."
  (or (p:ascii-letter? c)
      (p:digit? c)
      (char= c #\!)
      (char<= #\# c #\')
      (char<= #\* c #\+)
      (char= c #\-)
      (char= c #\/)
      (char= c #\=)
      (char= c #\?)
      (char<= #\^ c #\`)
      (char<= #\{ c #\~)))

(declaim (ftype (function (character) boolean) dtext?))
(defun dtext? (c)
  (or (char<= #\! c #\Z)
      (char<= #\^ c #\~)
      (obs-no-ws-ctl? c)))

(declaim (ftype (function (character) boolean) obs-no-ws-ctl?))
(defun obs-no-ws-ctl? (c)
  (or (char<= #\Soh c #\backspace)
      (char<= #\Vt c #\Page)
      (char<= #\So c #\Us)
      (char= #\Rubout c)))

(declaim (ftype (function (character character) boolean) quoted-pair?))
(defun quoted-pair? (a b)
  (and (char= a #\\)
       (or (char<= #\! b #\~)
           (ws? b)
           (char= b #\nul)
           (obs-no-ws-ctl? b)
           (crlf? b))))

#+nil
(quoted-pair? #\\ #\newline)

(declaim (ftype (function (character) boolean) qtext?))
(defun qtext? (c)
  (or (char= #\! c)
      (char<= #\# c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

(declaim (ftype (function (character) boolean) ctext?))
(defun ctext? (c)
  (or (char<= #\! c #\')
      (char<= #\* c #\[)
      (char<= #\] c #\~)
      (obs-no-ws-ctl? c)))

;; --- Static Parsers --- ;;

(defparameter +@+             (p:char #\@))
(defparameter +bracket-open+  (p:char #\[))
(defparameter +bracket-close+ (p:char #\]))
(defparameter +period+        (p:char #\.))
(defparameter +paren-open+    (p:char #\())
(defparameter +paren-close+   (p:char #\)))
(defparameter +quote+         (p:char #\"))
(defparameter +any-crlf+      (p:any-if #'crlf?))
(defparameter +consume-ws+    (p:consume #'ws?))
(defparameter +consume-atext+ (p:consume1 #'atext?))
(defparameter +skipws1+       (p:consume1 #'ws?))
(defparameter +peek-@+        (p:peek (p:alt +@+ #'p:eof)))
(defparameter +peek-eof+      (p:peek #'p:eof))

;; --- Types --- ;;

(defstruct address
  "A valid email address. Must be obtained through the parsing process and cannot
be directly constructed by the user."
  (name   nil :type string)
  (domain nil :type string))

(defun pretty (addr &optional (stream nil))
  "Pretty-print an `address'. Not at all guaranteed to be an isomorphism
with the original string from which the address was parsed, as the original may
have contained any number of junk characters or comments."
  (format stream "~a@~a" (address-name addr) (address-domain addr)))

#+nil
(pretty (p:parse #'msg-id "colin@fosskers.ca"))

;; --- Entry --- ;;

(defun parse (input)
  "Attempt to parse an email address."
  (p:parse (<* #'addr-spec #'p:eof) input))

(declaim (ftype (function (string) boolean) valid-email-address?))
(defun valid-email-address? (s)
  (let ((s (etypecase s
             ((simple-array character (*)) s)
             (string (coerce s '(simple-array character (*)))))))
    (multiple-value-bind (res next) (funcall (<* #'addr-spec #'p:eof) (p:in s))
      (declare (ignore next))
      (p:ok? res))))

#+nil
(valid-email-address? "alice@bob.com")
#+nil
(valid-email-address? "alice")

;; --- Whitespace and Comments --- ;;

(defparameter +consume-ws-crlf+ (p:opt (*> +consume-ws+ +any-crlf+)))

(defparameter +fws+ (p:alt (*> +consume-ws-crlf+ +skipws1+) #'obs-fws))

(defun fws (offset)
  "Parser: Folding white space."
  (funcall +fws+ offset))

#+nil
(p:parse #'fws "   ")

(defparameter +opt-fws+ (p:opt #'fws))

(defparameter +obs-fws+
  (*> +skipws1+
      (p:many (*> +any-crlf+ +skipws1+))))

(defun obs-fws (offset)
  (funcall +obs-fws+ offset))

#+nil
(p:parse #'obs-fws "   ")

(defparameter +many-comments+
  (p:many1 (*> +opt-fws+ #'comment)))

;; NOTE: From the spec.
;;
;; > Runs of FWS, comment, or CFWS that occur between lexical tokens in a
;; > structured header field are semantically interpreted as a single space
;; > character.))
;;
;; I interpret this to mean that comments and run of spaces can be entirely
;; ignored within an address.
(defun cfws (offset)
  (funcall (p:alt (*> +many-comments+ +opt-fws+)
                  #'fws)
           offset))

(defparameter +opt-cfws+ (p:opt #'cfws))

(defparameter +comment+
  (p:between +paren-open+
             (*> (p:many (*> +opt-fws+ #'ccontent))
                 +opt-fws+)
             +paren-close+))

(defun comment (offset)
  "Yields NIL if successful."
  (funcall +comment+ offset))

#+nil
(p:parse #'comment "(hello(there))")

(defun ccontent (offset)
  (funcall (p:alt (sliding-take1 (lambda (a b)
                                   (cond ((ctext? a) (values :one a))
                                         ((quoted-pair? a b) (values :two b)))))
                  #'comment)
           offset))

#+nil
(p:parse #'ccontent "hello)")

;; --- Atoms --- ;;

(defparameter +period-sep-atext+
  (p:consume-sep1 +period+ +consume-atext+))

(defun dot-atom-text (offset)
  "Parser: Simple dot-separated ascii atoms."
  (funcall (p:recognize +period-sep-atext+) offset))

#+nil
(p:parse #'dot-atom-text "foo.bar.baz")

(defparameter +dot-atom+
  (p:between +opt-cfws+
             #'dot-atom-text
             +opt-cfws+))

(defun dot-atom (offset)
  (funcall +dot-atom+ offset))

#+nil
(p:parse #'dot-atom "   (hi)hello(there)    ")

;; --- Content Parsers --- ;;

(defun addr-spec (offset)
  (funcall (p:ap (lambda (name domain) (make-address :name name :domain domain))
                 #'local-part
                 (*> +@+ #'domain))
           offset))

#+nil
(p:parse #'addr-spec "   alice  (comment)   @bob.com")

#+nil
(p:parse #'addr-spec "alice@bob@charles.com")

(defun local-part (offset)
  (funcall (p:alt (<* #'dot-atom +peek-@+)
                  (<* #'quoted-string +peek-@+)
                  #'obs-local-part)
           offset))

(defun domain (offset)
  (funcall (p:alt (<* #'dot-atom +peek-eof+)
                  #'domain-literal
                  #'obs-domain)
           offset))

;; Whitespace: https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.2

(defun quoted-string (offset)
  "No whitespace around or within the quotes is considered actual content."
  (p:fmap (lambda (list) (apply #'concatenate 'string list))
          (funcall (*> +opt-cfws+
                       +quote+
                       ;; FIXME: 2025-09-10 This `many' is wasteful and forces a
                       ;; reallocation into a single string above. I'm not sure
                       ;; how to get around it though, given that `fws' has a
                       ;; specific structure that is not just a matter of
                       ;; `consuming' over whitespace.
                       (<* (p:many (*> +opt-fws+
                                       (sliding-take1 (lambda (a b)
                                                        (cond ((qtext? a) (values :one a))
                                                              ((quoted-pair? a b) (values :two b)))))))
                           +opt-fws+
                           +quote+
                           +opt-cfws+))
                   offset)))

#+nil
(p:parse #'quoted-string "\"hello \\\" there\"")

(defun obs-local-part (offset)
  (p:fmap (lambda (list) (format nil "~{~a~^.~}" list))
          (funcall (p:sep1 +period+ #'word) offset)))

#+nil
(p:parse #'obs-local-part "hello . there . hi")

(defun domain-literal (offset)
  (p:fmap (lambda (list) (format nil "[~{~a~}]" (cadr list)))
          (funcall (p:between +opt-cfws+
                              (<*> +bracket-open+
                                   (p:many (*> +opt-fws+
                                               #'many-dtext1))
                                   (*> +opt-fws+ +bracket-close+))
                              +opt-cfws+)
                   offset)))

#+nil
(p:parse #'domain-literal "[hello there]")

(defun obs-domain (offset)
  (p:fmap (lambda (list) (format nil "~{~a~^.~}" list))
          (funcall (p:sep1 +period+ #'atom) offset)))

#+nil
(p:parse #'obs-domain "yes . hello . there")

(defun word (offset)
  (funcall (p:alt #'atom #'quoted-string) offset))

(defun atom (offset)
  (funcall (p:between +opt-cfws+
                      (p:take-while1 #'atext?)
                      +opt-cfws+)
           offset))

#+nil
(p:parse #'atom " hello ")

(defun msg-id (offset)
  (p:fmap (lambda (list) (make-address :name (car list) :domain (cadr list)))
          (funcall (<*> #'id-left (*> +@+ #'id-right)) offset)))

#+nil
(p:parse #'msg-id "colin@fosskers.ca")

(defun id-left (offset)
  (funcall (p:alt #'dot-atom-text #'local-part) offset))

(defun id-right (offset)
  (funcall (p:alt #'dot-atom-text #'no-fold-literal #'domain) offset))

(defun no-fold-literal (offset)
  (funcall (p:recognize (*> +bracket-open+ #'many-dtext +bracket-close+)) offset))

(defun many-dtext (offset)
  "Parser: Potentially escaped characters."
  (funcall (sliding-take (lambda (a b)
                           (cond ((dtext? a) (values :one a))
                                 ((quoted-pair? a b) (values :two b)))))
           offset))

#+nil
(p:parse #'many-dtext "Hello\\ there")
#+nil
(p:parse #'many-dtext "Hello there")

(defun many-dtext1 (offset)
  "Parser: Potentially escaped characters."
  (multiple-value-bind (res next) (many-dtext offset)
    (cond ((p:failure? res) (p:fail offset))
          ((p:empty? res) (p:fail offset))
          (t (values res next)))))

#+nil
(p:parse #'many-dtext1 "")

;; --- Utilities --- ;;

;; (declaim (ftype (function ((function (character character) (values keyword character)))
;;                           (values string fixnum))
;;                 sliding-take))
(defun sliding-take (f)
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((s (make-array 16 :element-type 'character :adjustable t :fill-pointer 0))
           (keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\Nul)))
                             (multiple-value-bind (kw c) (funcall f a b)
                               (case kw
                                 (:one
                                  (incf i)
                                  (vector-push-extend c s))
                                 (:two
                                  (incf i 2)
                                  (vector-push-extend c s))
                                 (t (return (- i offset))))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (values s next))))

#+nil
(p:parse (sliding-take (lambda (a b)
                         (cond ((and (char= a #\\)
                                     (char= b #\n))
                                (values :two #\newline))
                               (t (values :one a)))))
         "Hello \\n there!")

(defun sliding-take1 (f)
  (lambda (offset)
    (multiple-value-bind (res next) (funcall (sliding-take f) offset)
      (cond ((p:failure? res) (p:fail offset))
            ((p:empty? res) (p:fail offset))
            (t (values res next))))))

#+nil
(p:parse (sliding-take1 (lambda (a b)
                          (cond ((and (char= a #\\)
                                      (char= b #\n))
                                 (values :two #\newline))
                                (t (values :one a)))))
         "")
