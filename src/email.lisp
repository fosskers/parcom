;;; RFC5322-compliant email parsing.
;;;
;;; For clarity, the name of each parser in this package is lifted directly from
;;; the spec and the layout of the parsers generally follows the ABNF, except
;;; where doing so literally would be inefficient. Specifically, some of the
;;; low-level character checks have been fused into smarter `take-while' calls.
;;;
;;; See also the following relevant sections in various RFCs.
;;;
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4
;;; - https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
;;; - https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1
;;;
;;; A note on obsolete syntax. From RFC 5322:
;;;
;;; > Section 4 of this document specifies an "obsolete" syntax. There are
;;; > references in section 3 to these obsolete syntactic elements. The rules of
;;; > the obsolete syntax are elements that have appeared in earlier versions of
;;; > this specification or have previously been widely used in Internet
;;; > messages. As such, these elements MUST be interpreted by parsers of
;;; > messages in order to be conformant to this specification. However, since
;;; > items in this syntax have been determined to be non-interoperable or to
;;; > cause significant problems for recipients of messages, they MUST NOT be
;;; > generated by creators of conformant messages.
;;;
;;; parcom/email supports parsing this obsolete syntax.

(defpackage parcom/email
  (:use :cl)
  (:import-from :parcom #:<*> #:<* #:*> #:<$)
  (:local-nicknames (#:p #:parcom))
  ;; --- Types --- ;;
  (:export #:address #:address-name #:address-domain))

(in-package :parcom/email)

;; --- Static Parsers --- ;;

(defparameter +@+ (p:char #\@))
(defparameter +bracket-open+ (p:char #\[))
(defparameter +bracket-close+ (p:char #\]))
(defparameter +period+ (p:char #\.))

;; --- Types --- ;;

(defstruct address
  "A valid email address. Must be obtained through the parsing process and cannot
be directly constructed by the user."
  (name   nil :type string)
  (domain nil :type string))

(defun pretty (addr &optional (stream nil))
  "Pretty-print an `address'."
  (format stream "~a@~a" (address-name addr) (address-domain addr)))

#+nil
(pretty (p:parse #'msg-id "colin@fosskers.ca"))

;; --- Entry --- ;;

;; TODO: Convert to a simple-array if not already one.
(declaim (ftype (function (string) boolean) valid-address?))
(defun valid-email-address? (s))

;; --- Parsers --- ;;

(defun addr-spec (offset)
  (funcall (<*> local-part (*> +@+ domain)) offset))

(defun local-part (offset)
  (funcall (p:alt #'dot-atom #'quoted-string #'obs-local-part) offset))

(defun domain (offset)
  (funcall (p:alt #'dot-atom #'domain-literal #'obs-domain) offset))

;; Whitespace: https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.2

;; TODO: 2025-09-05 Start here. Provide both the simpler `msg-id' parser and the
;; full `address' one from above. If you can prove the former works, then the
;; latter should be easier.

(defun msg-id (offset)
  (p:fmap (lambda (list) (make-address :name (car list) :domain (cadr list)))
          (funcall (<*> #'id-left (*> +@+ #'id-right)) offset)))

#+nil
(p:parse #'msg-id "colin@fosskers.ca")

(defun id-left (offset)
  (funcall (p:alt #'dot-atom-text #'local-part) offset))

(defun id-right (offset)
  (funcall (p:alt #'dot-atom-text #'no-fold-literal #'domain) offset))

(defun no-fold-literal (offset)
  (funcall (p:recognize (*> +bracket-open+ #'many-dtext +bracket-close+)) offset))

(defun many-dtext (offset)
  "Parser: Potentially escaped characters."
  (funcall (sliding-take (lambda (a b)
                           (cond ((or (char<= #\! a #\Z)
                                      (char<= #\^ a #\~)
                                      (obs-no-ws-ctl? a))
                                  (values :one a))
                                 ((quoted-pair? a b)
                                  (values :two b)))))
           offset))

#+nil
(p:parse #'many-dtext "Hello\\ there")

(declaim (ftype (function (character) boolean) obs-no-ws-ctl?))
(defun obs-no-ws-ctl? (c)
  (or (char<= #\Soh c #\backspace)
      (char<= #\Vt c #\Page)
      (char<= #\So c #\Us)
      (char= #\Rubout c)))

(declaim (ftype (function (character character) boolean) quoted-pair?))
(defun quoted-pair? (a b)
  (and (char= a #\\)
       (or (char<= #\! b #\~)
           (char= b #\space)
           (char= b #\tab)
           (char= b #\nul)
           (obs-no-ws-ctl? b)
           (char= b #\newline)
           (char= b #\return))))

#+nil
(quoted-pair? #\\ #\newline)

(declaim (ftype (function (character) boolean) atext?))
(defun atext? (c)
  "Printable US-ASCII characters not including specials."
  (or (p:ascii-letter? c)
      (p:digit? c)
      (char= c #\!)
      (char<= #\# c #\')
      (char<= #\* c #\+)
      (char= c #\-)
      (char= c #\/)
      (char= c #\=)
      (char= c #\?)
      (char<= #\^ c #\`)
      (char<= #\{ c #\~)))

(defun dot-atom-text (offset)
  "Parser: Simple dot-separated ascii atoms."
  (funcall (p:recognize (p:sep1 +period+ (p:take-while1 #'atext?))) offset))

#+nil
(p:parse #'dot-atom-text "foo.bar.baz")

;; dtext           =   %d33-90 /          ; Printable US-ASCII
;;                     %d94-126 /         ;  characters not including
;;                     obs-dtext          ;  "[", "]", or "\"

;; obs-dtext       =   obs-NO-WS-CTL / quoted-pair)

;; quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp

;; VCHAR          =  %x21-7E)
;;                        ; visible (printing) characters

;; WSP            =  SP / HTAB)
;;                        ; white space

;; SP             =  %x20)

;; HTAB           =  %x09))
;;                        ; horizontal tab

;; obs-qp          =   \ (%d0 / obs-NO-WS-CTL / LF / CR)

;; LF             =  %x0A
;;                        ; linefeed

;; CR             =  %x0D
;;                        ; carriage return

;; obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control
;;                     %d11 /             ;  characters that do not
;;                     %d12 /             ;  include the carriage
;;                     %d14-31 /          ;  return, line feed, and
;;                     %d127              ;  white space characters

;; --- Utilities --- ;;

;; TODO: 2025-09-06 Start here. Use this to parse escape characters.

;; (declaim (ftype (function ((function (character character) keyword))) consume2))
(defun consume2 (p)
  "Like `consume' from the main library, but inspects two characters at a time in
a sliding window. This is intended for the detection of slash-escaped character
pairs.

Note that the given predicate-lambda must yield a keyword. `:one' will advance
the parser by one place. `:two' will advance it by two (i.e. the escaped char
case). Anything else is equivalent to NIL and will halt the consumption.

In the event that the parser advanced to the very last character via a `:one'
step, a `#\Nul' character will be passed as the second one to the
predicate-lambda."
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\0))
                                  (kw (funcall p a b)))
                             (case kw
                               (:one (incf i))
                               (:two (incf i 2))
                               (t (return (- i offset)))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (p:ok next next))))

#+nil
(p:parse (consume2 (lambda (a b)
                     (cond ((and (char= a #\a) (char= b #\b)) :two)
                           ((char= a #\a) :one))))
         "aabb")

;; TODO: 2025-09-07 Looks like I need to filter out comments and all sorts of
;; other gross things, so this won't be a matter of just using `recognize' on
;; everything. For some simple parts yes, but in general I will have to actually
;; claim each character into a new string.

;; (declaim (ftype (function ((function (character character) (values keyword character)))
;;                           (values string fixnum))
;;                 sliding-take))
(defun sliding-take (f)
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((s (make-array 16 :element-type 'character :adjustable t :fill-pointer 0))
           (keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\Nul)))
                             (multiple-value-bind (kw c) (funcall f a b)
                               (case kw
                                 (:one
                                  (incf i)
                                  (vector-push-extend c s))
                                 (:two
                                  (incf i 2)
                                  (vector-push-extend c s))
                                 (t (return (- i offset))))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (values s next))))

#+nil
(p:parse (sliding-take (lambda (a b)
                         (cond ((and (char= a #\\)
                                     (char= b #\n))
                                (values :two #\newline))
                               (t (values :one a)))))
         "Hello \\n there!")
