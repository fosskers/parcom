;;; RFC5322-compliant email parsing.
;;;
;;; For clarity, the name of each parser in this package is lifted directly from
;;; the spec.
;;;
;;; See also the following relevant sections in various RFCs.
;;;
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1
;;; - https://datatracker.ietf.org/doc/html/rfc5322#section-3.6.4
;;; - https://datatracker.ietf.org/doc/html/rfc5321#section-4.1.2
;;; - https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1
;;;
;;; A note on obsolete syntax. From RFC 5322:
;;;
;;; > Section 4 of this document specifies an "obsolete" syntax. There are
;;; > references in section 3 to these obsolete syntactic elements. The rules of
;;; > the obsolete syntax are elements that have appeared in earlier versions of
;;; > this specification or have previously been widely used in Internet
;;; > messages. As such, these elements MUST be interpreted by parsers of
;;; > messages in order to be conformant to this specification. However, since
;;; > items in this syntax have been determined to be non-interoperable or to
;;; > cause significant problems for recipients of messages, they MUST NOT be
;;; > generated by creators of conformant messages.
;;;
;;; parcom/email supports parsing this obsolete syntax.

(defpackage parcom/email
  (:use :cl)
  (:import-from :parcom #:<*> #:<* #:*> #:<$)
  (:local-nicknames (#:p #:parcom)))

(in-package :parcom/email)

;; --- Static Parsers --- ;;

(defparameter +@+ (p:char #\@))
(defparameter +bracket-open+ (p:char #\[))
(defparameter +bracket-close+ (p:char #\]))
(defparameter +period+ (p:char #\.))

;; --- Entry --- ;;

;; TODO: Convert to a simple-array if not already one.
(declaim (ftype (function (string) boolean) valid-address?))
(defun valid-email-address? (s))

;; --- Parsers --- ;;

(defun addr-spec (offset)
  (funcall (<*> local-part (*> +@+ domain)) offset))

(defun local-part (offset)
  (funcall (p:alt #'dot-atom #'quoted-string #'obs-local-part) offset))

(defun domain (offset)
  (funcall (p:alt #'dot-atom #'domain-literal #'obs-domain) offset))

;; Whitespace: https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.2

;; TODO: 2025-09-05 Start here. Provide both the simpler `msg-id' parser and the
;; full `address' one from above. If you can prove the former works, then the
;; latter should be easier.

(defun msg-id (offset)
  (funcall (<*> #'id-left (*> +@+ #'id-right)) offset))

(defun id-left (offset)
  (funcall (p:alt #'dot-atom-text #'local-part) offset))

(defun id-right (offset)
  (funcall (p:alt #'dot-atom-text #'no-fold-literal #'domain) offset))

(defun no-fold-literal (offset)
  (funcall (p:recognize (*> +bracket-open+ #'dtext +bracket-close+)) offset))

(defun dtext (offset)
  ())

(declaim (ftype (function (character) boolean) atext?))
(defun atext? (c)
  "Printable US-ASCII characters not including specials."
  (or (p:ascii-letter? c)
      (p:digit? c)
      ;; FIXME: 2025-09-06 See if you can fold these into range comparisons. It
      ;; might just be a set that excludes @.
      (char= c #\!)
      (char= c #\#)
      (char= c #\$)
      (char= c #\%)
      (char= c #\&)
      (char= c #\')
      (char= c #\*)
      (char= c #\+)
      (char= c #\-)
      (char= c #\/)
      (char= c #\=)
      (char= c #\?)
      (char= c #\^)
      (char= c #\_)
      (char= c #\`)
      (char= c #\{)
      (char= c #\|)
      (char= c #\})
      (char= c #\~)))

(defun dot-atom-text (offset)
  "Parser: Simple dot-separated ascii atoms."
  (funcall (p:recognize (p:sep1 +period+ (p:take-while1 #'atext?))) offset))

#+nil
(p:parse #'dot-atom-text "foo.bar.baz")

;; dtext           =   %d33-90 /          ; Printable US-ASCII
;;                     %d94-126 /         ;  characters not including
;;                     obs-dtext          ;  "[", "]", or "\"

;; obs-dtext       =   obs-NO-WS-CTL / quoted-pair)

;; quoted-pair     =   ("\" (VCHAR / WSP)) / obs-qp

;; VCHAR          =  %x21-7E)
;;                        ; visible (printing) characters

;; WSP            =  SP / HTAB)
;;                        ; white space

;; SP             =  %x20)

;; HTAB           =  %x09))
;;                        ; horizontal tab

;; obs-qp          =   \ (%d0 / obs-NO-WS-CTL / LF / CR)

;; LF             =  %x0A
;;                        ; linefeed

;; CR             =  %x0D
;;                        ; carriage return

;; obs-NO-WS-CTL   =   %d1-8 /            ; US-ASCII control
;;                     %d11 /             ;  characters that do not
;;                     %d12 /             ;  include the carriage
;;                     %d14-31 /          ;  return, line feed, and
;;                     %d127              ;  white space characters

;; --- Utilities --- ;;

(declaim (ftype (function ((function (character character) keyword))) consume2))
(defun consume2 (p)
  "Like `consume' from the main library, but inspects two characters at a time in
a sliding window. This is intended for the detection of slash-escaped character
pairs.

Note that the given predicate-lambda must yield a keyword. `:one' will advance
the parser by one place. `:two' will advance it by two (i.e. the escaped char
case). Anything else is equivalent to NIL and will halt the consumption.

In the event that the parser advanced to the very last character via a `:one'
step, a `#\Nul' character will be passed as the second one to the
predicate-lambda."
  (lambda (offset)
    (declare (optimize (speed 3) (safety 0)))
    (let* ((keep (loop :with i fixnum := offset
                       :while (< i p::*input-length*)
                       :do (let* ((a (schar p::*input* i))
                                  (b (if (< i (1- p::*input-length*))
                                         (schar p::*input* (1+ i))
                                         #\0))
                                  (kw (funcall p a b)))
                             (case kw
                               (:one (incf i))
                               (:two (incf i 2))
                               (t (return (- i offset)))))
                       :finally (return (- i offset))))
           (next (p::off keep offset)))
      (p:ok next next))))

#+nil
(p:parse (consume2 (lambda (a b)
                     (cond ((and (char= a #\a) (char= b #\b)) :two)
                           ((char= a #\a) :one))))
         "aaabb")
