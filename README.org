#+title: parcom - Parser Combinators

=parcom= is a consise Parser Combinator library in the style of Haskell's =parsec=
and Rust's =nom=.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (*> (string "Tempus") #'space (string "fugit")) "Tempus fugit.")
#+end_src

#+RESULTS:
: fugit

=parcom= operates strictly on strings, not streamed byte data, but is otherwise
"zero copy" in that extracted substrings of the original input are not
reallocated.

=parcom= has no dependencies.

* Table of Contents :TOC_5_gh:noexport:
- [[#compatibility][Compatibility]]
- [[#performance][Performance]]
- [[#api][API]]
  - [[#types-and-running-parsers][Types and Running Parsers]]
  - [[#parsers][Parsers]]
    - [[#characters-and-strings][Characters and Strings]]
      - [[#char][char]]
      - [[#string][string]]
      - [[#any][any]]
      - [[#anybut][anybut]]
      - [[#hex][hex]]
      - [[#eof][eof]]
    - [[#numbers][Numbers]]
      - [[#unsigned][unsigned]]
      - [[#integer][integer]]
      - [[#float][float]]
    - [[#whitespace][Whitespace]]
      - [[#newline][newline]]
      - [[#space-space1][space, space1]]
      - [[#multispace-multispace1][multispace, multispace1]]
    - [[#taking-in-bulk][Taking in Bulk]]
      - [[#take][take]]
      - [[#take-while-take-while1][take-while, take-while1]]
      - [[#rest][rest]]
  - [[#combinators][Combinators]]
    - [[#-right][*>, right]]
    - [[#-left][<*, left]]
    - [[#-all][<*>, all]]
    - [[#-instead][<$, instead]]
    - [[#alt][alt]]
    - [[#opt][opt]]
    - [[#between][between]]
    - [[#many-many1][many, many1]]
    - [[#sep-sep1][sep, sep1]]
    - [[#sep-end-sep-end1][sep-end, sep-end1]]
    - [[#skip][skip]]
    - [[#consume][consume]]
    - [[#peek][peek]]
    - [[#count][count]]
    - [[#recognize][recognize]]
  - [[#utilities][Utilities]]
    - [[#empty][empty?]]
    - [[#digit][digit?]]
    - [[#fmap][fmap]]
    - [[#const][const]]
  - [[#json][JSON]]
    - [[#parse][parse]]
    - [[#json-1][json]]
- [[#writing-your-own-parsers][Writing your own Parsers]]
  - [[#basics][Basics]]
  - [[#parameterized-parsers][Parameterized Parsers]]
  - [[#failure][Failure]]

* Compatibility

| Compiler  | Status |
|-----------+--------|
| SBCL      | ✅    |
| ECL       | ✅    |
| Clasp     | ❓    |
| ABCL      | ✅    |
| CCL       | ✅    |
| Clisp     | ✅    |
| Allegro   | ✅    |
| LispWorks | ❓    |

* Performance

=parcom= operates over =simple-string= input, accessing its elements with =schar=. As
it internally signals parsing success or failure via structs, it does a fair
amount of allocation. That said, its =parcom/json= component has been measured to
parse JSON at ~10mb/s on a 2016 ThinkPad, which should be sufficient for
ordinary usage. There are certainly faster parsers out there, but =parcom= is
expressive and light.

* API

The examples below use =(in-package :parcom)= for brevity, but it's assumed that
you'll use a local nickname like =pc= in your actual code. Further, most examples
run the parsers with =parse=, but occasionally =funcall= is used instead to
demonstrate what the remaining input would be after the parse succeeded. You
will generally be using =parse= in your own code.

** Types and Running Parsers

All parsers have the function signature =input -> parser=, where =input= keeps track
of the original string and the current parsing offset, and =parser= is a struct
that holds the value of the parsing success alongside the updated (i.e. newly
offset) =input=.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (string "Hello") (in "Hello there"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 5 :STR "Hello there") :VALUE "Hello")

Of course, a parser might fail, in which case a =failure= struct is returned:

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (string "Hello") (in "Bye!"))
#+end_src

#+RESULTS:
: #S(FAILURE :EXPECTED "Hello" :ACTUAL #S(INPUT :CURR 0 :STR "Bye!"))

In general though, we call =parse= to fully run some combined parsers and yield
the final output:

#+begin_src lisp :exports both
(in-package :parcom)
(apply #'+ (parse (sep (char #\.) #'unsigned) "123.456.789!"))
#+end_src

#+RESULTS:
: 1368

=parse= otherwise ignores any final, unconsumed input. It will also raise a
Condition if the parsing failed.

** Parsers

A "parser" is a function that consumes some specific input and yields a single
result.

*** Characters and Strings
**** char

Parse a given character.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (char #\a) "apple")
#+end_src

#+RESULTS:
: #\a

**** string

Parse the given string. The parsed string is a slice into the original input.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (string "Hello") "Hello there!")
#+end_src

#+RESULTS:
: Hello

**** any

Parse any character.

#+begin_src lisp :exports both
(in-package :parcom)
(parse #'any "Hello there!")
#+end_src

#+RESULTS:
: #\H

**** anybut

Parse any character except the one you don't want.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (anybut #\!) "Hello there!")
#+end_src

#+RESULTS:
: #\H

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (anybut #\H) (in "Hello there!"))
#+end_src

#+RESULTS:
: #S(FAILURE :EXPECTED #\H :ACTUAL #S(INPUT :CURR 0 :STR "Hello there!"))

**** hex

Parse a hex character of any case.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (many #'hex) "abcd0efgh")
#+end_src

#+RESULTS:
: (#\a #\b #\c #\d #\0 #\e #\f)

**** eof

Recognize the end of the input.

#+begin_src lisp :exports both
(in-package :parcom)
(parse #'eof "")
#+end_src

#+RESULTS:
: T

#+begin_src lisp :exports both
(in-package :parcom)
(parse (*> (string "Mālum") #'eof) "Mālum")
#+end_src

#+RESULTS:
: T

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (*> (string "Mālum") #'eof) (in "Mālum rubrum"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "the end of the input"
:    :ACTUAL #S(INPUT :CURR 5 :STR "Mālum rubrum"))

*** Numbers
**** unsigned

Parse a positive integer into a =fixnum=.

#+begin_src lisp :exports both
(in-package :parcom)
(parse #'unsigned "44")
#+end_src

#+RESULTS:
: 44

**** integer

Parse a positive or negative integer into a =fixnum=.

#+begin_src lisp :exports both
(in-package :parcom)
(parse #'integer "-44")
#+end_src

#+RESULTS:
: -44

**** float

Parse a positive or negative floating point number into a =double-float=.

#+begin_src lisp :exports both
(in-package :parcom)
(parse #'float "123.0456")
#+end_src

#+RESULTS:
: 123.0456d0

*** Whitespace
**** newline

Matches a single newline character.

#+begin_src lisp :exports both
(in-package :parcom)
(let ((s (concatenate 'cl:string '(#\newline #\a #\b #\c)))) ; "\nabc"
  (parse #'newline s))
#+end_src

#+RESULTS:
: #\Newline

**** space, space1

Parse 0 or more ASCII whitespace and tab characters.

#+begin_src lisp :exports both
(in-package :parcom)
(length (parse #'space "   Salvē!"))
#+end_src

#+RESULTS:
: 3

Parse 1 or more ASCII whitespace and tab characters.

#+begin_src lisp :exports both
(in-package :parcom)
(length (parse #'space1 "   Salvē!"))
#+end_src

#+RESULTS:
: 3

#+begin_src lisp :exports both
(in-package :parcom)
(funcall #'space1 (in "Salvē!"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "space1: at least one whitespace"
:    :ACTUAL #S(INPUT :CURR 0 :STR "Salvē!"))

**** multispace, multispace1

Parse 0 or more ASCII whitespace, tabs, newlines, and carriage returns.

#+begin_src lisp :exports both
(in-package :parcom)
(length (parse #'multispace (concatenate 'cl:string '(#\tab #\newline #\tab))))
#+end_src

#+RESULTS:
: 3

Parse 1 or more ASCII whitespace, tabs, newlines, and carriage returns.

#+begin_src lisp :exports both
(in-package :parcom)
(length (parse #'multispace1 (concatenate 'cl:string '(#\tab #\newline #\tab))))
#+end_src

#+RESULTS:
: 3

#+begin_src lisp :exports both
(in-package :parcom)
(funcall #'multispace1 (in "Ārcus"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "multispace1: at least one space-like character"
:    :ACTUAL #S(INPUT :CURR 0 :STR "Ārcus"))

*** Taking in Bulk

These always yield a substring borrowed directly from the original input.

**** take

Take =n= characters from the input.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (take 3) "Arbor")
#+end_src

#+RESULTS:
: Arb

**** take-while, take-while1

Take characters while some predicate holds.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (take-while (lambda (c) (equal #\a c))) "aaabbb")
#+end_src

#+RESULTS:
: aaa

=take-while1= is like =take-while=, but must yield at least one character.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (take-while1 (lambda (c) (equal #\a c))) (in "bbb"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "take-while1: at least one success"
:    :ACTUAL #S(INPUT :CURR 0 :STR "bbb"))

**** rest

Consume the rest of the input. Always succeeds.

#+begin_src lisp :exports both :results verbatim
(in-package :parcom)
(parse (<*> (string "Salvē") (*> #'space #'rest)) "Salvē domine!")
#+end_src

#+RESULTS:
: ("Salvē" "domine!")

** Combinators

"Combinators" combine child parsers together to form compound results. They
allow us to express intent like "parse this then that" and "parse this, then
maybe that, but only if..." etc.

*** *>, right

Run multiple parsers one after another, but yield the value of the rightmost
one. =right= is an alias.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (*> (char #\!) #'unsigned) "!123?")
#+end_src

#+RESULTS:
: 123

*** <*, left

Run multiple parsers one after another, but yield the value of the leftmost
one. =left= is an alias.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (<* (char #\!) #'unsigned) "!123?")
#+end_src

#+RESULTS:
: #\!

*** <*>, all

Combination of parsers yielding all results as a list. =all= is an alias.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (<*> #'unsigned (char #\!) #'unsigned) "123!456")
#+end_src

#+RESULTS:
: (123 #\! 456)

This library does not offer a currying mechanism, so the technique usually
available in Haskell of fmap'ing a function over chain of =<*>= must be done
instead with =apply=:

#+begin_src lisp :exports both
(in-package :parcom)
(apply #'+ (parse (<*> #'unsigned (*> (char #\!) #'unsigned)) "123!456"))
#+end_src

#+RESULTS:
: 579

*** <$, instead

Run some parser, but substitute its inner value with something else if parsing
was successful. =instead= is an alias.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (<$ :roma (string "Roma")) "Roma!")
#+end_src

#+RESULTS:
: :ROMA

*** alt

Accept the results of the first parser from a group to succeed. Can combine as
many parsers as you want.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (alt (string "dog") (string "cat")) "cat")
#+end_src

#+RESULTS:
: cat

*** opt

Yield =nil= if the parser failed, but don't fail the whole process nor consume any
input.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (opt (string "Ex")) "Exercitus")
#+end_src

#+RESULTS:
: Ex

#+begin_src lisp :exports both
(in-package :parcom)
(parse (opt (string "Ex")) "Facēre")
#+end_src

#+RESULTS:
: NIL

*** between

A main parser flanked by two other ones. Only the value of the main parser is
kept. Good for parsing backets, parentheses, etc.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (between (char #\!) (string "Salvē") (char #\!)) "!Salvē!")
#+end_src

#+RESULTS:
: Salvē

*** many, many1

=many= parses 0 or more occurrences of a parser. =many1= demands that at least one
parse succeeds or a Condition will be raised.

#+begin_src lisp :exports both :results verbatim
(in-package :parcom)
(parse (many (alt (string "ovēs") (string "avis"))) "ovēsovēsavis!")
#+end_src

#+RESULTS:
: ("ovēs" "ovēs" "avis")

*** sep, sep1

=sep= parses 0 or more instances of a parser separated by some =sep= parser. =sep1=
demands that at least one parse succeeds or a Condition will be raised.

#+begin_src lisp :exports both :results verbatim
(in-package :parcom)
(parse (sep (char #\!) (string "pilum")) "pilum!pilum!pilum.")
#+end_src

#+RESULTS:
: ("pilum" "pilum" "pilum")

Critically, if a separator is detected, the parent parser must also then succeed
or the entire combination fails. For example, this will not parse due to the =!=
on the end:

#+begin_src lisp :exports both :results verbatim
(in-package :parcom)
(funcall (sep (char #\!) (string "pilum")) (in "pilum!pilum!pilum!"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "pilum"
:    :ACTUAL #S(INPUT :CURR 18 :STR "pilum!pilum!pilum!"))

For more lenient behaviour regarding the separator, see =sep-end=.

*** sep-end, sep-end1

The same as =sep=, but the separator /may/ appear at the end of the final "parent".
Likewise, =sep-end1= demands that at least one parse of the parent succeeds.

#+begin_src lisp :exports both :results verbatim
(in-package :parcom)
(parse (sep-end (char #\!) (string "pilum")) "pilum!pilum!pilum!scūtum")
#+end_src

#+RESULTS:
: ("pilum" "pilum" "pilum")

*** skip

Parse some parser 0 or more times, but throw away all the results.

#+begin_src lisp :exports both
(in-package :parcom)
(parse (*> (skip (char #\!)) #'unsigned) "!!!123")
#+end_src

#+RESULTS:
: 123

*** consume

Skip characters according to a given predicate, advancing the parser to a
further point. Yields =T=, not the characters that were parsed. Can be used as a
faster variant of =take-while= or =multispace= when you don't actually need the
parsed characters.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (consume (lambda (c) (eql c #\a))) (in "aaabcd!"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 3 :STR "aaabcd!") :VALUE T)

*** peek

Yield the value of a parser, but don't consume the input.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (peek (string "he")) (in "hello"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 0 :STR "hello") :VALUE "he")

*** count

Apply a parser a given number of times and collect the results as a list.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (count 3 (char #\a)) (in "aaaaaa"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 3 :STR "aaaaaa") :VALUE (#\a #\a #\a))

*** recognize

If the given parser was successful, return the consumed input as a string
instead.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (recognize (<*> (string "hi") #'unsigned)) (in "hi123there"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 5 :STR "hi123there") :VALUE "hi123")

** Utilities

*** empty?

Is a given string empty?

#+begin_src lisp :exports both
(in-package :parcom)
(empty? "")
#+end_src

#+RESULTS:
: T

*** digit?

Is a given character a number from 0 to 9?

#+begin_src lisp :exports both
(in-package :parcom)
(digit? #\7)
#+end_src

#+RESULTS:
: T

*** fmap

Apply a pure function to the inner contents of a parser.

#+begin_src lisp :exports both
(in-package :parcom)
(fmap #'1+ (funcall #'unsigned (in "1")))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 1 :STR "1") :VALUE 2)

*** const

Yield a function that ignores its input and returns some original seed.

#+begin_src lisp :exports both
(in-package :parcom)
(funcall (const 1) 5)
#+end_src

#+RESULTS:
: 1

** JSON

By depending on the optional =parcom/json= system, you can parse JSON strings or
include parcom-compatible JSON parsers into your own custom parsing code.

=(in-package :parcom/json)= is used below for brevity, but it's assumed that in
your own code you will use a nickname, perhaps =pj=.

If you don't care about the individual parsers per se and just want to simply
parse some JSON, use =pj:parse=.

Conversions:

| JSON   | Lisp           |
|--------+----------------|
| =true=   | =T=              |
| =false=  | =NIL=            |
| Array  | Vector         |
| Object | Hash Table     |
| Number | =double-float= |
| String | String         |
| =null=   | =:NULL=          |

*Performance Note*

As with the parent =parcom= library, =parcom/json= works strictly off of strings.
With SBCL it parses JSON at about 10mb/s on my 2016 ThinkPad, which should be
sufficient for ordinary usage. For a more "industrial strength" JSON parsing
library, see [[https://github.com/Zulu-Inuoe/jzon][jzon]] which parses about 3-4x faster than =parcom/json=.

*** parse

Attempt to parse any JSON value. Analogous to =parse= from the main library.

#+begin_src lisp :exports both
(in-package :parcom/json)
(parse "{\"x\": 1, \"y\": 2, \"z\": [1, {\"a\":true}]}")
#+end_src

#+RESULTS:
: #<HASH-TABLE :TEST EQUAL :COUNT 3 {100E9D5F73}>

#+begin_src lisp :exports both :results verbatim
(in-package :parcom/json)
(parse "[1.9,true,3e+7,\"hi\",[4],null]")
#+end_src

#+RESULTS:
: #(1.9d0 T 3.0d7 "hi" #(4) :NULL)

Non-ascii and unicode characters are supported:

#+begin_src lisp :exports both
(in-package :parcom/json)
(parse "\"hēllお🐂\\u03B1\"")
#+end_src

#+RESULTS:
: hēllお🐂α

*** json

Parse any kind of JSON (the actual parser).

#+begin_src lisp :exports both
(in-package :parcom/json)
(json (parcom:in "{\"x\": 1, \"y\": 2, \"z\": [1, {\"a\":true}]}  "))
#+end_src

#+RESULTS:
: #S(P:PARSER
:    :INPUT #S(P:INPUT
:              :CURR 38
:              :STR "{\"x\": 1, \"y\": 2, \"z\": [1, {\"a\":true}]}  ")
:    :VALUE #<HASH-TABLE :TEST EQUAL :COUNT 3 {100EBF43E3}>)

There are other subparsers exposed, but they are left out here for brevity.
Please consult the source code if you need them.

* Writing your own Parsers

** Basics

The whole point of Parser Combinators is that it becomes simple to write your
own parsing functions. Recall that a "fully realized" parser has the signature
=input -> parser=. In the simplest case, a parser of yours could look like:

#+begin_src lisp :exports both
(in-package :parcom)

(defun excited-apple (input)
  (funcall (<* (string "Mālum") (char #\!)) input))

(funcall #'excited-apple (in "Mālum! Ō!"))
#+end_src

#+RESULTS:
: #S(PARSER :INPUT #S(INPUT :CURR 6 :STR "Mālum! Ō!") :VALUE "Mālum")

Wherein you utilize the combinators provided by this library to build up
composite parsers that are useful to you.

** Parameterized Parsers

You can also parameterize your parsers, similar to parsers like =take= or
combinators like =count=:

#+begin_src lisp :exports both
(in-package :parcom)

(defun excited-apple (input)
  (funcall (<* (string "Mālum") (char #\!)) input))

(defun excited-apples (n)
  "Parse a certain number of excited apples."
  (lambda (input)
    (funcall (count n #'excited-apple) input)))

(funcall (excited-apples 3) (in "Mālum!Mālum!Mālum!Mālum!"))
#+end_src

#+RESULTS:
: #S(PARSER
:    :INPUT #S(INPUT :CURR 18 :STR "Mālum!Mālum!Mālum!Mālum!")
:    :VALUE ("Mālum" "Mālum" "Mālum"))

So, if your parser is parameterized by some initial argument, it has to return a
lambda that accepts an =input=.

** Failure

You can use =fail= within more complex hand-written parsers to explicitly fail
with your own diagnostics:

#+begin_src lisp :exports both
(in-package :parcom)

(defun three-sad-pears (input)
  (let ((res (funcall (many (string "Pirum trīste")) input)))
    (cond ((failure-p res)
           (fail "Three sad pears" input))
          ((< (length (parser-value res)) 3)
           (fail "Three sad pears" input))
          ((> (length (parser-value res)) 3)
           (fail "Three sad pears" input))
          (t res))))

(three-sad-pears (in "Pirum trīste"))
#+end_src

#+RESULTS:
: #S(FAILURE
:    :EXPECTED "Three sad pears"
:    :ACTUAL #S(INPUT :CURR 0 :STR "Pirum trīste"))

Notice the usage of =parser-value= to access the current inner success value of
the =parser= result. =parser-input= is likewise used to access the remaining input.
